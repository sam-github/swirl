See:

http://beepcore-c.sourceforge.net/
http://www.beepcore.org/
http://www.lua.org/

Note:

Since beepcore-c is an abandoned project, it might seem odd that I should use
it to implement swirl. I chose it because its architecture seems to be designed
for ease of embedding in a host language. It's architecture is described here:

http://beepcore-c.sourceforge.net/Architecture.html

Swirl discards the multi-threaded, overly complex, and overly ambitious wrapper
portions of the library, and is implemented directly on the "core".


BUG I'm pretty sure profile content with embedded NUL screws things up, despite
that its supposed to be transparently encoded.

BUG sessions aren't being GCed until lua state is destroyed, why not?


http://www.aspl.es/vortex/btf.html

http://www.beepcore.org/seq_frames.html


* Session Establishment

Accepted profiles need to be known at time of session creation, because they
are listed in session initialization message (the greeting). These are the
profiles for which a start may be accepted (i.e., server profiles).


> greeting:
    features?
    localize?
    profile*
      profile: -- no content!
        uri

Normal act of creating a session.

> err:
    code
    msg?
    lang?

The listener can refuse to accept a session. This might be because of a policy
violation (too many connections, not willing to accept from the initiators IP,
etc.), for example.


* Channel Start

> start:
    profile+
      profile:
        uri
	  -- profile is identified by URI
	content?
	  -- optional content, meaningful for this profile
	encoding?
	  -- whether content is base64 encoded, defaults to false
	  -- internal: handled by the core
    chno -- allocated by core
    servername? -- if accepted, holds for whole session, but is generally
      -- useful only for tuning

Client calls :start(), server gets on_start(ch0).

< accept:
    profile
      uri

Server calls ch0:accept(), client gets on_started().

< reject:
    error:
      code
        -- error code, see appendix of RFC 3080
      msg
        -- diagnostic message
      lang
        -- language of message

Server calls ch0:reject(), client gets on_start_err().


> close:
    chno
    code
      -- should default to 200/success
    msg?
    lang?

Active calls :close(), passive gets on_close(ch0).

< ok:

Passive calls ch:accept(), active gets on_closed().

< err:
    code
    msg?
    lang?


Passive calls ch:reject(), active gets on_close_err().


** Session Close

A close on channel 0 is a request to close the connection. The transport is closed.

NOTE - the RFC doesn't say whether or not this can be done when there are other
channels still open (but quiescent), or if it can be done with channels still
open with unfinished message exchanges.


Write example using swirl of a server with random delays to messages,
countering the necessity of the "asynch" draft.



** Message Exchange

send_msg()/send_rpy()
send_msg()/send_err()
send_msg()/send_ans()..., send_nul()




http://lua-users.org/wiki/FinalizedExceptions


- Frame vs. Msg

Its important to deal with receiving partial messages, but its annoying if you
know your messages are small. What to do?

Session creator could spec a max msg size, and wrapper could accumulate frames,
delivering them when they are complete, or they are over msg size. Could be
per-channel. That would allow usual case to mean that you don't get small
frames do to chopping a msg to fit in window, but still completely leave up to
them the choice of accumulating larger frames, or saying it's invalid.
