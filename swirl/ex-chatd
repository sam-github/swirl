#!/usr/bin/env lua

require"quote"
require"socket"
require"sockext"
require"swirl"


-- Setup

loop = sockext.loop

q = quote.quote

URI = "http://example.com/beep/chat"

USAGE = "usage: "..arg[0].." <port>"

if arg[1] == "-v" then
  verbose = true
  table.remove(arg, 1)
end

port = assert(tonumber(arg[1]), "no port\n"..USAGE)


-- Chat server:

sessions = {}

function join(sess, chno, name)
  if not name then
    return swirl.ecodes.invalidparam, "chat content is not the name"
  elseif sess.user then
    return swirl.ecodes.invalidparam, "chatting already"
  else
    print("ADD USER", q(name))
    sess.user = { name = name, chno = chno }
  end
end

function leave(sess, chno)
  print("DROP USER", q(sess.user.name))
  speak(sess, "bye!")
  sess.user = nil
end

function speak(sess, payload, more)
  sess.user.msg = (sess.user.msg or "")..payload

  if more then
    print("MSG FROM", sess.user.name, "...")
    return
  end

  print("MSG FROM", sess.user.name)
  print(sess.user.msg)

  -- send msg to all sessions other than ours
  for k,other in pairs(sessions) do
    if other ~= sess  and other.user then
      print("@", q(other.user.name))
      other:send_msg(other.user.chno, sess.user.name.." says "..q(sess.user.msg))
    end
  end

  sess.user.msg = nil
end


-- Bind swirl to chat server

chat = {il="L", profiles = {URI}}

function chat.on_start(ch0)
  print(".. on_start:", ch0:channelno(), q(ch0:profiles()), q(ch0:servername()))
  local p
  for i, profile in pairs(ch0:profiles()) do
    if profile.uri == URI then
      p = profile
      break
    end
  end
  if not p then
    ch0:reject(swirl.ecodes.unavailable)
    return
  end

  local ecode, emsg = join(ch0:session(), ch0:channelno(), p.content)

  if ecode then
    ch0:reject(ecode, emsg)
  else
    ch0:accept(p.uri)
  end
end

function chat.on_close(ch0)
  local ecode, emsg, elang = ch0:error()
  print(".. on_close:", ch0:session(), ch0:channelno(), ecode, q(emsg), elang)

  leave(ch0:session())

  ch0:accept()

  -- FIXME shut tcp connection if chno == 0?
  --    No, not yet, but when? We have to wait until everything is quiet?
end

function chat.on_msg(frame)
  local sess, more, payload = frame:session(), frame:more(), frame:payload()
  print(".. on_msg:", sess, frame:channelno(), frame:messageno(), more, #payload)

  speak(sess, payload, more)

  if not frame:more() then
    sess:send_rpy(frame:channelno(), frame:messageno(), "")
  end

  frame:destroy()
end

function chat.on_pullable(sess)
  print(".. on_pullable", q(sess))
  loop.send(sess.client, send)
end

function chat.on_pushable(sess)
  print(".. on_pushable", q(sess))
  loop.receive(sess.client, receive)
end

-- Bind loop to swirl
-- TODO with on_pushable and on_pullable, these lists could be managed without polling

server = assert(socket.bind("*", port))
server:settimeout(0)

function accept(server)
  print(".. accept from", q(server))
  client = server:accept()
  if not client then
    -- oops, client died before we accepted
  else
    sess = swirl.session(chat)
    sess.client = client
    sessions[client] = sess -- I can't index socket userdata, so map externally.
    loop.receive(client, receive)
    loop.send(client, send)
  end
end

function send(client)
  sess = sessions[client]

  local data = sess:pull()

  if not data then
    loop.send(client)
    return
  end

  if verbose then
    print"--- I < L"
    print(data)
    print"---"
  end

  local sz, emsg = client:send(data)

  if sz then
    sess:pulled(sz)
  else
    print("DEATH of client", emsg)
    -- FIXME how to deal with this?
  end
end

function receive(client)
  local data, emsg = sockext.receive(client, "*f", swirl.BUFSZ)
  if data then
    if verbose then
      print"--- I > L"
      print(data)
      print"---"
    end
    local ok, emsg = sessions[client]:push(data)

    if not ok then
      local eno, emsg, echan = sessions[client]:status()
      print("ERROR", eno, emsg, echan)
    end
  elseif emsg == "timeout" then
    -- ignore
  else
    -- close this session
    loop.receive(client)
    loop.send(client)
  end
end

loop.receive(server, accept)
loop.start()

