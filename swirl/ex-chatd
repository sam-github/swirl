#!/usr/bin/env lua

require"quote"
require"socket"
require"sockext"
require"swirl"


-- Setup

loop = sockext.loop

q = quote.quote

CHAT = "http://example.com/beep/chat"

USAGE = "usage: "..arg[0].." <port>"

if arg[1] == "-v" then
  verbose = true
  table.remove(arg, 1)
end

port = assert(tonumber(arg[1]), "no port\n"..USAGE)


-- Chat server:

users = {}

function join(core, chno, name)
  if not name then
    return swirl.ecodes.invalidparam, "chat content is not the name"
  elseif core.user then
    return swirl.ecodes.invalidparam, "chatting already"
  else
    print("ADD USER", q(name))
    core.user = { name = name, chno = chno }
  end
end

function leave(core, chno)
  print("DROP USER", q(core.user.name))
  core.user = nil
end

function speak(core, payload, more)
  core.user.msg = (core.user.msg or "")..payload

  if more then
    print("MSG FROM", core.user.name, "...")
    return
  end

  print("MSG FROM", core.user.name)
  print(core.user.msg)

  -- send msg to all users other than ours
  for k,other in pairs(users) do
    if other ~= core  and other.user then
      print("@", q(other.user.name))
      other:send_msg(other.user.chno, core.user.name.." says "..q(core.user.msg))
    end
  end

  core.user.msg = nil
end


-- Bind swirl to chat server

chat = {il="L", profile = {CHAT}}

function chat.on_start(ch0)
  print(".. on_start:", ch0:channelno(), q(ch0:profiles()), q(ch0:servername()))
  local p
  for i, profile in pairs(ch0:profiles()) do
    if profile.uri == CHAT then
      p = profile
      break
    end
  end
  if not p then
    ch0:reject(swirl.ecodes.unavailable)
    return
  end

  local ecode, emsg = join(ch0:core(), ch0:channelno(), p.content)

  if ecode then
    ch0:reject(ecode, emsg)
  else
    ch0:accept(p.uri)
  end
end

function chat.on_close(ch0)
  local ecode, emsg, elang = ch0:error()
  print(".. on_close:", ch0:core(), ch0:channelno(), ecode, q(emsg), elang)

  leave(ch0:core())

  ch0:accept()
end

function chat.on_msg(frame)
  local core, more, payload = frame:core(), frame:more(), frame:payload()
  print(".. on_msg:", core, frame:channelno(), frame:messageno(), more, #payload)

  speak(core, payload, more)

  if not frame:more() then
    core:send_rpy(frame:channelno(), frame:messageno(), "")
  end

  frame:destroy()
end

function chat.on_pullable(core)
  print(".. on_pullable", q(core))
  loop.send(core.client, send)
end

function chat.on_pushable(core)
  print(".. on_pushable", q(core))
  loop.receive(core.client, receive)
end

-- Bind loop to swirl
-- TODO with on_pushable and on_pullable, these lists could be managed without polling

server = assert(socket.bind("*", port))
server:settimeout(0)

function accept(server)
  print(".. accept from", q(server))
  client = server:accept()
  if not client then
    -- oops, client died before we accepted
  else
    core = swirl.core(chat)
    core.client = client
    users[client] = core -- I can't index socket userdata, so map externally.
    loop.receive(client, receive)
    loop.send(client, send)
  end
end

function clear(client)
    loop.receive(client)
    loop.send(client)
    users[client] = nil
end

function send(client)
  core = users[client]

  local data = core:pull()

  if not data then
    loop.send(client)
    return
  end

  if verbose then
    print"--- I < L"
    print(data)
    print"---"
  end

  local sz, emsg = client:send(data)

  if sz then
    core:pulled(sz)
  else
    print("DIED", core.user and core.user.name, emsg)

    clear(client)
  end
end

function receive(client)
  local data, emsg = sockext.receive(client, "*f", swirl.BUFSZ)
  if data then
    if verbose then
      print"--- I > L"
      print(data)
      print"---"
    end
    local ok, emsg = users[client]:push(data)

    if not ok then
      local eno, emsg, echan = users[client]:status()
      print("ERROR", eno, emsg, echan)
    end
  elseif emsg == "timeout" then
    -- ignore
  else
    core = users[client]
    if core.user then
      print("DIED", core.user and core.user.name, emsg)
    end
    clear(client)
  end
end

loop.receive(server, accept)
loop.start()

