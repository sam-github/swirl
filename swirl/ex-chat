#!/usr/bin/env lua

require"quote"
require"sockext"
require"swirl"


-- Setup

loop = sockext.loop

q = quote.quote

URI = "http://example.com/beep/chat"

USAGE = "usage: "..arg[0].." <port> [host]"

port = assert(tonumber(arg[1]), "no port\n"..USAGE)
host = arg[2] or "localhost"

local print = function () end

io.stdout:setvbuf"no"


local file
local client
local sess

-- We handle 3 loop events: receive/send on client, and receive on file.

function read(file)
  print("..read", q(line))
  local line = io.read"*l"
  if not line then
    -- end of chat
    sess:close(chno)
    loop.receive(file)
  else
    sess:send_msg(chno, line)
    --io.stdout:write"> "
  end
  -- sess state has changed, it may be pullable
  loop.send(client, send)
end

function receive(client)
  print("..receive")
  local data, emsg = sockext.receive(client, "*f", swirl.BUFSZ)
  if data then
    sess:push(data)
    -- sess state has changed, it may be pullable
    loop.send(client, send)
  elseif emsg == "closed" then
    os.exit(0)
  else
    io.stderr:write("unexpected error on socket - "..emsg)
    os.exit(1)
  end
end

function send(client)
  print("..send")
  local data = sess:pull()
  if not data then
    -- not interested in the send event
    loop.send(client)
  else
    -- FIXME - partial sends?
    client:send(data)
  end
end

local chat = {il="I"}

function chat.on_connected()
  print("..connected")
  sess:start(URI, os.getenv"USER" or "anonymous")
end

function chat.on_started(_chno)
  print("..started", _chno)
  chno = _chno
  -- ready to start reading
  --io.stdout:write"> "
  loop.receive(file, read)
end

function chat.on_start_err(chno, ecode, emsg, elang)
  error(string.format("error %d, %s", ecode, emsg or swirl.ecodes[ecode] or "unknown"))
end

function chat.on_closed()
  print("..closed")
  os.exit(0)
end

function chat.on_msg(frame)
  print("..on_msg", frame, q(frame:payload()))
  local out = frame:payload()
  out = out:gsub("\r", "")
  out = out:gsub("\n", "\n| ")
  io.stdout:write("| ", out, "\n")
  if not frame:more() then
    sess:send_rpy(frame:channelno(), frame:messageno(), "")
  end
end

file = sockext.selectable(0)
client = assert(socket.connect(host, port))
sess = swirl.session(chat)

loop.receive(client, receive)
loop.send(client, send)

loop.start()

