#!/usr/bin/env lua

require"quote"
require"sockext"
require"swirl"


-- Setup

loop = sockext.loop

q = quote.quote

URI = "http://example.com/beep/chat"

USAGE = "usage: "..arg[0].." <port> [host]"

if arg[1] == "-v" then
  verbose = true
  table.remove(arg, 1)
end

port = assert(tonumber(arg[1]), "no port\n"..USAGE)
host = arg[2] or "localhost"

if not verbose then
  print = function () end
end

io.stdout:setvbuf"no"

local file
local client
local core

-- We handle 3 loop events: receive/send on client, and receive on file.

function read(file)
  print(".. read", q(line))
  local line = io.read"*l"
  if not line then
    -- end of chat
    core:close(0)
    loop.receive(file)
  else
    core:send_msg(chno, line)
    --io.stdout:write"> "
  end
  -- core state has changed, it may be pullable
  loop.send(client, send)
end

function receive(client)
  print(".. receive")
  local data, emsg = sockext.receive(client, "*f", swirl.BUFSZ)
  if data then
    core:push(data)
    -- core state has changed, it may be pullable
    loop.send(client, send)
  elseif emsg == "closed" then
    os.exit(0)
  else
    io.stderr:write("unexpected error on socket - "..emsg)
    os.exit(1)
  end
end

function send(client)
  print(".. send")
  local data = core:pull()
  if not data then
    loop.send(client)
  else
    local sz = assert(client:send(data))
    core:pulled(sz)
  end
end

local chat = {il="I"}

function chat.on_connected()
  print(".. connected")
  core:start(URI, os.getenv"USER" or "anonymous")
end

function chat.on_started(core, _chno)
  print(".. started", _chno)
  chno = _chno
  -- ready to start reading
  --io.stdout:write"> "
  loop.receive(file, read)
end

function chat.on_start_err(core, chno, ecode, emsg, elang)
  error(string.format("error %d, %s", ecode, emsg or swirl.ecodes[ecode] or "unknown"))
end

function chat.on_closed()
  print(".. closed")
  os.exit(0)
end

function chat.on_msg(frame)
  print(".. on_msg", frame, q(frame:payload()))
  local out = frame:payload()
  out = out:gsub("\r", "")
  out = out:gsub("\n", "\n| ")
  io.stdout:write("| ", out, "\n")
  if not frame:more() then
    core:send_rpy(frame:channelno(), frame:messageno(), "")
  end
end

function chat.on_pullable(core)
  print(".. on_pullable")
  loop.send(client, send)
end

file = sockext.selectable(0)
client = assert(socket.connect(host, port))
core = swirl.core(chat)

loop.receive(client, receive)
loop.send(client, send)

loop.start()

