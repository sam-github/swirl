#!/usr/bin/env lua

NULL = "http://example.com/beep/null"

require"quote"
require"argp"
require"swirlsock"

-- Arguments

USAGE = "usage: "..arg[0].." port=INT [host=STR] [time=INT] [size=INT] [seq=INT] [par=INT]"

arg.host     = "localhost"
arg.time     = 5
arg.size     = 5000
arg.seq      = 2
arg.par      = 1

argp.expand(arg)

arg.port = assert(tonumber(arg.port), "no port\n"..USAGE)
arg.time = assert(tonumber(arg.time))

print("options: "..quote.quote(arg))

verbose = arg.verbose

if arg.verbose then
  trace = print
else
  trace = function () end
end

BUF = string.rep("x", arg.size)

-- Null client

null = {}

function null.on_connected(core)
  trace(".. on_connected")
  null.core = core
  core.user = 0 -- total bytes acknowledged to have been transferred
  for _=1,arg.par do
    assert(core:start(NULL))
  end
end

function null.on_started(core, chno)
  trace(".. on_started")
  
  if not t0 then
    -- TODO when using N parallel channels, this means the benchmarks includes
    -- the overhead of starting the next N-1 channels.
    t0 = os.time()
  end

  -- keep outgoing queue full
  for _=1,arg.seq do
    assert(core:send_msg(chno, BUF))
  end
end

function null.on_rpy(frame)
  trace(".. on_rpy", frame:messageno(), frame:payload())

  local core = frame:core()

  core.user = core.user + assert(tonumber(frame:payload()))

  trace(".. xfersz = "..core.user)

  t1 = os.time()

  if t1 - t0 > arg.time then
    t = t1 - t0
    print("seq", arg.seq, "par", arg.par, "b", core.user, "t", t, "rate", core.user/1000/t, "kb/s")
    os.exit(0)
  end

  assert(frame:core():send_msg(frame:channelno(), BUF))

  frame:destroy()
end

-- Start loop

assert(swirl.connect(null, arg.port, arg.host))

sockext.loop.start()

